========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/main_window.py ==========
from PySide6 import QtWidgets, QtGui, QtCore
from data_explorer.ui.dialogs.connection_dialog import ConnectionDialog
from data_explorer.database.connection import connect_to_db, ConnectionError
from data_explorer.ui.widgets.schema_browser import SchemaBrowser
from data_explorer.ui.widgets.query_editor import QueryEditor
from data_explorer.ui.widgets.results_view import ResultsView
from data_explorer.ui.widgets.visualization_view import VisualizationView
from data_explorer.config import Config  # Import the Config class


class MainWindow(QtWidgets.QMainWindow):
    """
    The main application window.
    """

    def __init__(self):
        super().__init__()

        # --- Config Handling ---
        self.config = Config()
        self.recent_connections = self.config.get_recent_connections()

        # --- Window Setup ---
        window_size = self.config.get("window").get("size")
        window_pos = self.config.get("window").get("position")
        window_maximized = self.config.get("window").get("maximized")

        self.setWindowTitle("PG Data Explorer")
        self.setGeometry(window_pos[0], window_pos[1], window_size[0], window_size[1])

        if window_maximized:
            self.setWindowState(QtCore.Qt.WindowMaximized)

        # --- Central Widget ---
        central_widget = QtWidgets.QWidget()
        self.setCentralWidget(central_widget)

        # --- Layout ---
        main_layout = QtWidgets.QVBoxLayout(central_widget)

        # --- Toolbar ---
        self.main_toolbar = QtWidgets.QToolBar("Main Toolbar")
        self.addToolBar(self.main_toolbar)

        # Add connect button for more visibility
        connect_button = QtGui.QAction(
            self.style().standardIcon(QtWidgets.QStyle.SP_ComputerIcon),
            "Connect to Database",
            self,
        )
        connect_button.triggered.connect(self.open_connection_dialog)
        self.main_toolbar.addAction(connect_button)

        # Add execute query button
        execute_button = QtGui.QAction(
            self.style().standardIcon(QtWidgets.QStyle.SP_MediaPlay),
            "Execute Query",
            self,
        )
        execute_button.triggered.connect(self.execute_query)
        self.main_toolbar.addAction(execute_button)

        # Add disconnect button
        disconnect_button = QtGui.QAction(
            self.style().standardIcon(QtWidgets.QStyle.SP_BrowserStop),
            "Disconnect",
            self,
        )
        disconnect_button.triggered.connect(self.disconnect_database)
        disconnect_button.setEnabled(False)
        self.main_toolbar.addAction(disconnect_button)
        self.disconnect_button = disconnect_button

        # --- Split Views ---
        # Create main horizontal splitter (schema browser | query+results)
        self.h_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)

        # Create schema browser
        self.schema_browser = SchemaBrowser()
        self.h_splitter.addWidget(self.schema_browser)

        # Create right side panel (with tabs)
        self.right_panel = QtWidgets.QTabWidget()

        # Create query/results tab
        query_results_tab = QtWidgets.QWidget()
        query_results_layout = QtWidgets.QVBoxLayout(query_results_tab)

        # Create vertical splitter for query editor and results
        self.v_splitter = QtWidgets.QSplitter(QtCore.Qt.Vertical)

        # Create query editor
        self.query_editor = QueryEditor()
        self.v_splitter.addWidget(self.query_editor)

        # Create results view
        self.results_view = ResultsView()
        self.v_splitter.addWidget(self.results_view)

        # Set initial sizes for vertical splitter
        v_splitter_sizes = self.config.get("splitters").get("v_splitter")
        self.v_splitter.setSizes(v_splitter_sizes)

        query_results_layout.addWidget(self.v_splitter)
        self.right_panel.addTab(query_results_tab, "Query & Results")

        # Create visualization tab
        self.visualization_view = VisualizationView()
        self.right_panel.addTab(self.visualization_view, "Visualization")

        # Add right panel to horizontal splitter
        self.h_splitter.addWidget(self.right_panel)

        # Set initial sizes for horizontal splitter
        h_splitter_sizes = self.config.get("splitters").get("h_splitter")
        self.h_splitter.setSizes(h_splitter_sizes)

        # Add splitter to main layout
        main_layout.addWidget(self.h_splitter)

        # --- Status Bar ---
        self.status_bar = self.statusBar()
        self.status_bar.showMessage("Ready")

        # --- Connection Indicator ---
        self.connection_indicator = QtWidgets.QLabel("Not Connected")
        self.connection_indicator.setStyleSheet("color: red;")
        self.connection_indicator.setAlignment(QtCore.Qt.AlignCenter)
        self.connection_indicator.setMinimumWidth(150)
        self.status_bar.addPermanentWidget(self.connection_indicator)

        # --- Database Connection State ---
        self.db_connection = None  # Store the active connection object

        # --- Menu Bar ---
        self.setup_menu()

        # --- Connect Signals ---
        self.connect_signals()

        # --- Connect Splitter Moved Signals to Save Config ---
        self.h_splitter.splitterMoved.connect(self.save_splitter_sizes)
        self.v_splitter.splitterMoved.connect(self.save_splitter_sizes)

    def setup_menu(self):
        """Creates the main menu bar."""
        menu_bar = self.menuBar()

        # File Menu
        file_menu = menu_bar.addMenu("&File")

        connect_action = QtGui.QAction("&Connect to Database...", self)
        connect_action.setStatusTip("Open dialog to connect to a PostgreSQL database")
        connect_action.setShortcut("Ctrl+N")
        connect_action.triggered.connect(self.open_connection_dialog)
        file_menu.addAction(connect_action)

        # Recent connections submenu
        self.recent_menu = QtWidgets.QMenu("Recent Connections", self)
        self.update_recent_connections_menu()
        file_menu.addMenu(self.recent_menu)

        disconnect_action = QtGui.QAction("&Disconnect", self)
        disconnect_action.setStatusTip("Disconnect from the current database")
        disconnect_action.setShortcut("Ctrl+D")
        disconnect_action.triggered.connect(self.disconnect_database)
        disconnect_action.setEnabled(False)  # Disabled initially
        file_menu.addAction(disconnect_action)
        self.disconnect_action = disconnect_action  # Store reference to enable/disable

        file_menu.addSeparator()

        export_menu = QtWidgets.QMenu("Export", self)

        export_results_action = QtGui.QAction("Export Results to CSV...", self)
        export_results_action.triggered.connect(self.export_results_to_csv)
        export_menu.addAction(export_results_action)

        export_chart_action = QtGui.QAction("Export Chart...", self)
        export_chart_action.triggered.connect(self.export_visualization)
        export_menu.addAction(export_chart_action)

        file_menu.addMenu(export_menu)

        file_menu.addSeparator()

        exit_action = QtGui.QAction("E&xit", self)
        exit_action.setStatusTip("Exit the application")
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)

        # Query Menu
        query_menu = menu_bar.addMenu("&Query")

        execute_action = QtGui.QAction("&Execute", self)
        execute_action.setShortcut("F5")
        execute_action.setStatusTip("Execute the current query")
        execute_action.triggered.connect(self.execute_query)
        query_menu.addAction(execute_action)

        clear_action = QtGui.QAction("&Clear Editor", self)
        clear_action.setStatusTip("Clear the query editor")
        clear_action.triggered.connect(self.clear_query)
        query_menu.addAction(clear_action)

        query_menu.addSeparator()

        query_history_menu = QtWidgets.QMenu("Recent Queries", self)
        self.update_query_history_menu()
        query_menu.addMenu(query_history_menu)
        self.query_history_menu = query_history_menu

        # View Menu
        view_menu = menu_bar.addMenu("&View")

        view_query_results_action = QtGui.QAction("Query && Results", self)
        view_query_results_action.triggered.connect(
            lambda: self.right_panel.setCurrentIndex(0)
        )
        view_menu.addAction(view_query_results_action)

        view_visualizations_action = QtGui.QAction("Visualizations", self)
        view_visualizations_action.triggered.connect(
            lambda: self.right_panel.setCurrentIndex(1)
        )
        view_menu.addAction(view_visualizations_action)

        view_menu.addSeparator()

        toggle_sidebar_action = QtGui.QAction("Toggle Schema Browser", self)
        toggle_sidebar_action.setShortcut("Ctrl+S")
        toggle_sidebar_action.triggered.connect(self.toggle_schema_browser)
        view_menu.addAction(toggle_sidebar_action)

        # Settings Menu
        settings_menu = menu_bar.addMenu("&Settings")

        preferences_action = QtGui.QAction("&Preferences", self)
        preferences_action.setStatusTip("Configure application settings")
        preferences_action.triggered.connect(self.show_preferences_dialog)
        settings_menu.addAction(preferences_action)

        # Help Menu
        help_menu = menu_bar.addMenu("&Help")

        about_action = QtGui.QAction("&About", self)
        about_action.triggered.connect(self.show_about_dialog)
        help_menu.addAction(about_action)

    def connect_signals(self):
        """Connect signals between components."""
        # Connect schema browser table selection to query editor
        self.schema_browser.tableSelected.connect(self.on_table_selected)

        # Connect schema browser query generation to query editor
        self.schema_browser.queryGenerated.connect(self.on_query_generated)

        # Connect query editor execution to results view
        self.query_editor.queryExecuted.connect(self.on_query_executed)

        # Connect right panel tab change
        self.right_panel.currentChanged.connect(self.on_tab_changed)

    def save_splitter_sizes(self):
        """Save splitter sizes to config when they change."""
        splitters = self.config.get("splitters")
        splitters["h_splitter"] = self.h_splitter.sizes()
        splitters["v_splitter"] = self.v_splitter.sizes()
        self.config.set("splitters", splitters)

    def save_window_state(self):
        """Save window size, position, and state to config."""
        window = self.config.get("window")

        # Only save size and position if not maximized
        if not self.isMaximized():
            window["size"] = [self.width(), self.height()]
            window["position"] = [self.x(), self.y()]

        window["maximized"] = self.isMaximized()
        self.config.set("window", window)

    def update_recent_connections_menu(self):
        """Update the recent connections menu with saved connections."""
        self.recent_menu.clear()

        if not self.recent_connections:
            no_recent_action = QtGui.QAction("No Recent Connections", self)
            no_recent_action.setEnabled(False)
            self.recent_menu.addAction(no_recent_action)
            return

        for conn in self.recent_connections:
            # Create a menu item with the connection details
            conn_name = f"{conn.get('dbname', '')}@{conn.get('host', '')}:{conn.get('port', '')}"
            action = QtGui.QAction(conn_name, self)
            action.setData(conn)  # Store the connection details
            action.triggered.connect(self.connect_to_recent)
            self.recent_menu.addAction(action)

        # Add a separator and clear action
        self.recent_menu.addSeparator()
        clear_action = QtGui.QAction("Clear Recent Connections", self)
        clear_action.triggered.connect(self.clear_recent_connections)
        self.recent_menu.addAction(clear_action)

    def update_query_history_menu(self):
        """Update the query history menu."""
        self.query_history_menu.clear()

        query_history = self.config.get_query_history()

        if not query_history:
            no_history_action = QtGui.QAction("No Recent Queries", self)
            no_history_action.setEnabled(False)
            self.query_history_menu.addAction(no_history_action)
            return

        # Add most recent queries (limit to 10 for menu usability)
        for i, query in enumerate(query_history[:10]):
            # Truncate long queries for menu display
            display_query = query[:50] + "..." if len(query) > 50 else query
            # Replace newlines with spaces for menu display
            display_query = display_query.replace("\n", " ")

            action = QtGui.QAction(display_query, self)
            action.setData(query)  # Store the full query
            action.triggered.connect(self.load_query_from_history)
            self.query_history_menu.addAction(action)

        # Add a separator and clear action if there are queries
        if query_history:
            self.query_history_menu.addSeparator()
            clear_action = QtGui.QAction("Clear Query History", self)
            clear_action.triggered.connect(self.clear_query_history)
            self.query_history_menu.addAction(clear_action)

    def load_query_from_history(self):
        """Load a query from history into the editor."""
        action = self.sender()
        if not action:
            return

        query = action.data()
        if not query:
            return

        # Set query in editor
        self.query_editor.editor.setPlainText(query)

        # Focus the editor
        self.query_editor.editor.setFocus()

        # Switch to query tab if on visualization
        if self.right_panel.currentIndex() == 1:
            self.right_panel.setCurrentIndex(0)

    def clear_query_history(self):
        """Clear the query history."""
        reply = QtWidgets.QMessageBox.question(
            self,
            "Clear Query History",
            "Are you sure you want to clear the query history?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No,
        )

        if reply == QtWidgets.QMessageBox.Yes:
            self.config.set("query_history", [])
            self.update_query_history_menu()

    def add_to_recent_connections(self, conn_details):
        """Add connection details to recent connections list."""
        # Use the Config class to add the connection
        self.config.add_recent_connection(conn_details)
        # Update our local copy
        self.recent_connections = self.config.get_recent_connections()
        # Update the menu
        self.update_recent_connections_menu()

    def clear_recent_connections(self):
        """Clear the recent connections list."""
        reply = QtWidgets.QMessageBox.question(
            self,
            "Clear Recent Connections",
            "Are you sure you want to clear the recent connections list?",
            QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
            QtWidgets.QMessageBox.No,
        )

        if reply == QtWidgets.QMessageBox.Yes:
            # Use the Config class to clear connections
            self.config.set("recent_connections", [])
            # Update our local copy
            self.recent_connections = []
            # Update the menu
            self.update_recent_connections_menu()

    def connect_to_recent(self):
        """Connect to a database from the recent connections menu."""
        action = self.sender()
        if not action:
            return

        # Get connection details
        conn_details = action.data()
        if not conn_details:
            return

        # Need to ask for password since we don't store it
        password, ok = QtWidgets.QInputDialog.getText(
            self,
            "Password Required",
            f"Enter password for {conn_details.get('user', '')}@{conn_details.get('dbname', '')}:",
            QtWidgets.QLineEdit.Password,
        )

        if not ok:
            return

        # Add password to connection details
        conn_details["password"] = password

        # Connect
        self.status_bar.showMessage("Connecting...")
        try:
            self.db_connection = connect_to_db(**conn_details)
            if self.db_connection:
                db_name = conn_details.get("dbname", "Unknown DB")
                host = conn_details.get("host", "Unknown Host")
                user = conn_details.get("user", "Unknown User")
                self.status_bar.showMessage(
                    f"Connected to '{db_name}' on '{host}' as '{user}'"
                )
                self.disconnect_action.setEnabled(True)
                self.disconnect_button.setEnabled(True)

                # Set up UI for connected state
                self.setup_connected_state(db_name, host)

                # Add to recent connections
                self.add_to_recent_connections(conn_details)
            else:
                self.status_bar.showMessage("Connection failed.")
        except ConnectionError as e:
            self.status_bar.showMessage(f"Connection Error: {e}")
            QtWidgets.QMessageBox.critical(
                self, "Connection Error", f"Failed to connect:\n{e}"
            )
        except Exception as e:
            self.status_bar.showMessage(f"An unexpected error occurred: {e}")
            QtWidgets.QMessageBox.critical(
                self, "Error", f"An unexpected error occurred:\n{e}"
            )

    def open_connection_dialog(self):
        """Opens the database connection dialog."""
        if self.db_connection:
            # Prevent opening if already connected - could ask to disconnect first
            QtWidgets.QMessageBox.warning(
                self,
                "Already Connected",
                "Please disconnect before connecting to a new database.",
            )
            return

        dialog = ConnectionDialog(self)
        if dialog.exec():
            conn_details = dialog.get_connection_details()
            self.status_bar.showMessage("Connecting...")
            try:
                self.db_connection = connect_to_db(**conn_details)
                if self.db_connection:
                    db_name = conn_details.get("dbname", "Unknown DB")
                    host = conn_details.get("host", "Unknown Host")
                    user = conn_details.get("user", "Unknown User")
                    self.status_bar.showMessage(
                        f"Connected to '{db_name}' on '{host}' as '{user}'"
                    )
                    self.disconnect_action.setEnabled(True)
                    self.disconnect_button.setEnabled(True)

                    # Set up UI for connected state
                    self.setup_connected_state(db_name, host)

                    # Add to recent connections
                    self.add_to_recent_connections(conn_details)
                else:
                    self.status_bar.showMessage("Connection failed.")
            except ConnectionError as e:
                self.status_bar.showMessage(f"Connection Error: {e}")
                QtWidgets.QMessageBox.critical(
                    self, "Connection Error", f"Failed to connect:\n{e}"
                )
            except Exception as e:
                self.status_bar.showMessage(f"An unexpected error occurred: {e}")
                QtWidgets.QMessageBox.critical(
                    self, "Error", f"An unexpected error occurred:\n{e}"
                )

    def setup_connected_state(self, db_name, host):
        """Set up the UI for a connected database state."""
        # Update window title to show connection info
        self.setWindowTitle(f"PG Data Explorer - {db_name}@{host}")

        # Update connection indicator
        self.connection_indicator.setText(f"Connected: {db_name}@{host}")
        self.connection_indicator.setStyleSheet("color: green; font-weight: bold;")

        # Update components with the connection
        self.schema_browser.populate_schema(self.db_connection)
        self.query_editor.set_connection(self.db_connection)

        # Clear any previous results
        self.results_view.clear_results()

    def disconnect_database(self):
        """Closes the current database connection."""
        if self.db_connection:
            try:
                self.db_connection.close()
                self.db_connection = None
                self.status_bar.showMessage("Disconnected.")
                self.disconnect_action.setEnabled(False)
                self.disconnect_button.setEnabled(False)

                # Reset UI state
                self.reset_ui_state()
            except Exception as e:
                self.status_bar.showMessage(f"Error during disconnection: {e}")
                QtWidgets.QMessageBox.warning(
                    self,
                    "Disconnection Error",
                    f"An error occurred while disconnecting:\n{e}",
                )
        else:
            self.status_bar.showMessage("Not currently connected.")

    def reset_ui_state(self):
        """Reset the UI to the disconnected state."""
        # Reset window title
        self.setWindowTitle("PG Data Explorer")

        # Update connection indicator
        self.connection_indicator.setText("Not Connected")
        self.connection_indicator.setStyleSheet("color: red;")

        # Clear schema browser
        self.schema_browser.clear()

        # Reset query editor
        self.query_editor.set_connection(None)

        # Clear results
        self.results_view.clear_results()

    def on_table_selected(self, schema_name, table_name):
        """Handle a table being selected in the schema browser."""
        # Get default query limit from config
        limit = self.config.get("query_limit", 100)

        # Generate a SELECT query for the table
        query = f"SELECT * FROM {schema_name}.{table_name} LIMIT {limit};"

        # Insert the query into the editor
        self.query_editor.editor.setPlainText(query)

        # Focus the query editor
        self.query_editor.editor.setFocus()

        # Switch to query tab if on visualization
        if self.right_panel.currentIndex() == 1:
            self.right_panel.setCurrentIndex(0)

    def on_query_generated(self, query):
        """Handle a query being generated from the schema browser."""
        # Insert the query into the editor
        self.query_editor.editor.setPlainText(query)

        # Focus the query editor
        self.query_editor.editor.setFocus()

        # Switch to query tab if on visualization
        if self.right_panel.currentIndex() == 1:
            self.right_panel.setCurrentIndex(0)

    def on_query_executed(self, columns, data):
        """Handle query execution results."""
        # Display results in results view
        self.results_view.display_results(columns, data)

        # If there's data, also update visualization view
        if columns and data:
            self.visualization_view.set_data(columns, data)

            # Update status bar with suggestion to view visualizations
            if self.right_panel.currentIndex() == 0:  # If on query tab
                self.status_bar.showMessage(
                    f"Query returned {len(data)} rows. Switch to Visualization tab to explore data visually."
                )

    def on_tab_changed(self, index):
        """Handle tab changes."""
        if index == 1:  # Visualization tab
            # Make sure visualization has current data
            if (
                hasattr(self.results_view, "model")
                and self.results_view.model.rowCount() > 0
            ):
                # Get data from results view
                columns = []
                for i in range(self.results_view.model.columnCount()):
                    columns.append(
                        self.results_view.model.headerData(i, QtCore.Qt.Horizontal)
                    )

                data = []
                for i in range(self.results_view.model.rowCount()):
                    row = []
                    for j in range(self.results_view.model.columnCount()):
                        value = self.results_view.model.index(i, j).data(
                            QtCore.Qt.UserRole
                        )
                        row.append(value)
                    data.append(row)

                self.visualization_view.set_data(columns, data)

    def execute_query(self):
        """Execute the current query in the editor."""
        query = self.query_editor.editor.toPlainText().strip()
        if query:
            # Add to query history in config
            self.config.add_query_history(query)
            # Update the query history menu
            self.update_query_history_menu()

        # Execute the query
        self.query_editor.execute_query()

        # Switch to query results tab if on visualization
        if self.right_panel.currentIndex() == 1:
            self.right_panel.setCurrentIndex(0)

    def clear_query(self):
        """Clear the query editor."""
        self.query_editor.clear_query()

    def export_results_to_csv(self):
        """Export results to CSV."""
        if (
            not hasattr(self.results_view, "model")
            or self.results_view.model.rowCount() == 0
        ):
            self.status_bar.showMessage("No results to export")
            return

        self.results_view.export_to_csv()

    def export_visualization(self):
        """Export the current visualization."""
        if self.right_panel.currentIndex() != 1:
            self.right_panel.setCurrentIndex(1)

        self.visualization_view.export_chart()

    def toggle_schema_browser(self):
        """Toggle the visibility of the schema browser."""
        if self.schema_browser.isVisible():
            # Save current size
            self.schema_browser_size = self.h_splitter.sizes()[0]
            # Hide schema browser
            self.h_splitter.setSizes(
                [0, self.h_splitter.sizes()[1] + self.schema_browser_size]
            )
        else:
            # Restore schema browser
            if hasattr(self, "schema_browser_size"):
                self.h_splitter.setSizes(
                    [
                        self.schema_browser_size,
                        self.h_splitter.sizes()[1] - self.schema_browser_size,
                    ]
                )
            else:
                # Default size if no saved size
                self.h_splitter.setSizes([250, self.h_splitter.sizes()[1] - 250])

    def show_preferences_dialog(self):
        """Show the preferences dialog."""
        # Create preferences dialog
        dialog = QtWidgets.QDialog(self)
        dialog.setWindowTitle("Preferences")
        dialog.setMinimumWidth(400)

        # Main layout
        layout = QtWidgets.QVBoxLayout(dialog)

        # Tab widget for different preference categories
        tab_widget = QtWidgets.QTabWidget()

        # General preferences tab
        general_tab = QtWidgets.QWidget()
        general_layout = QtWidgets.QFormLayout(general_tab)

        # Query limit setting
        query_limit_spinner = QtWidgets.QSpinBox()
        query_limit_spinner.setRange(1, 10000)
        query_limit_spinner.setValue(self.config.get("query_limit", 100))
        query_limit_spinner.setSingleStep(100)
        general_layout.addRow("Default query limit:", query_limit_spinner)

        # Theme setting
        theme_combo = QtWidgets.QComboBox()
        theme_combo.addItems(["Light", "Dark", "System"])
        theme_combo.setCurrentText(self.config.get("theme", "System"))
        general_layout.addRow("Theme:", theme_combo)

        # Add to tab widget
        tab_widget.addTab(general_tab, "General")

        # Connection preferences tab
        connection_tab = QtWidgets.QWidget()
        connection_layout = QtWidgets.QFormLayout(connection_tab)

        # Default connection settings
        default_host = QtWidgets.QLineEdit(self.config.get("default_host", "localhost"))
        default_port = QtWidgets.QLineEdit(self.config.get("default_port", "5432"))
        default_user = QtWidgets.QLineEdit(self.config.get("default_user", ""))

        connection_layout.addRow("Default host:", default_host)
        connection_layout.addRow("Default port:", default_port)
        connection_layout.addRow("Default user:", default_user)

        # Add to tab widget
        tab_widget.addTab(connection_tab, "Connection")

        # Add tab widget to layout
        layout.addWidget(tab_widget)

        # Add buttons
        button_box = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.Ok | QtWidgets.QDialogButtonBox.Cancel
        )
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)

        # Show dialog
        if dialog.exec():
            # Save preferences if accepted
            self.config.set("query_limit", query_limit_spinner.value())
            self.config.set("theme", theme_combo.currentText())
            self.config.set("default_host", default_host.text())
            self.config.set("default_port", default_port.text())
            self.config.set("default_user", default_user.text())

            # Apply theme if changed
            self.apply_theme(theme_combo.currentText())

    def apply_theme(self, theme_name):
        """Apply the selected theme."""
        if theme_name == "System":
            # Use system theme
            QtWidgets.QApplication.setStyle(QtWidgets.QStyleFactory.create("Fusion"))
            return

        # Create palette for the theme
        palette = QtGui.QPalette()

        if theme_name == "Dark":
            # Set dark theme colors
            palette.setColor(QtGui.QPalette.Window, QtGui.QColor(53, 53, 53))
            palette.setColor(QtGui.QPalette.WindowText, QtCore.Qt.white)
            palette.setColor(QtGui.QPalette.Base, QtGui.QColor(25, 25, 25))
            palette.setColor(QtGui.QPalette.AlternateBase, QtGui.QColor(53, 53, 53))
            palette.setColor(QtGui.QPalette.ToolTipBase, QtCore.Qt.white)
            palette.setColor(QtGui.QPalette.ToolTipText, QtCore.Qt.white)
            palette.setColor(QtGui.QPalette.Text, QtCore.Qt.white)
            palette.setColor(QtGui.QPalette.Button, QtGui.QColor(53, 53, 53))
            palette.setColor(QtGui.QPalette.ButtonText, QtCore.Qt.white)
            palette.setColor(QtGui.QPalette.BrightText, QtCore.Qt.red)
            palette.setColor(QtGui.QPalette.Link, QtGui.QColor(42, 130, 218))
            palette.setColor(QtGui.QPalette.Highlight, QtGui.QColor(42, 130, 218))
            palette.setColor(QtGui.QPalette.HighlightedText, QtCore.Qt.black)
        else:  # Light theme
            # Use default palette
            palette = QtGui.QPalette()

        # Apply the palette
        QtWidgets.QApplication.setPalette(palette)

        # Set style to Fusion for consistent look
        QtWidgets.QApplication.setStyle(QtWidgets.QStyleFactory.create("Fusion"))

    def show_about_dialog(self):
        """Show the about dialog."""
        QtWidgets.QMessageBox.about(
            self,
            "About PG Data Explorer",
            """<h3>PG Data Explorer</h3>
            <p style="font-size: 12px;">A cross-platform PostgreSQL database explorer with advanced visualization capabilities and Odoo compatibility.</p>
            <p style="font-size: 12px;">Features:</p>
            <ul style="font-size: 12px;">
                <li>Connect to any PostgreSQL database</li>
                <li>Browse database schemas, tables, and columns</li>
                <li>Execute SQL queries with syntax highlighting</li>
                <li>Visualize query results with interactive charts</li>
                <li>Export data and visualizations</li>
                <li>Special support for Odoo database schema</li>
            </ul>
            <p style="font-size: 12px;">Created as a portfolio project showcasing database integration, data visualization, and UI design skills.</p>
            <p style="font-size: 12px;"><b>Version 1.0.0</b></p>""",
        )

    def closeEvent(self, event: QtGui.QCloseEvent):
        """Handle window close event to save state and disconnect."""
        # Save window state
        self.save_window_state()

        # Save splitter sizes
        self.save_splitter_sizes()

        # Disconnect from database
        self.disconnect_database()

        # Accept the close event
        event.accept()


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/__init__.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/dialogs/__init__.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/dialogs/connection_dialog.py ==========
from PySide6 import QtWidgets, QtCore


class ConnectionDialog(QtWidgets.QDialog):
    """
    A dialog window for entering PostgreSQL connection details.
    """

    def __init__(self, parent=None):
        super().__init__(parent)

        self.setWindowTitle("Connect to PostgreSQL Database")
        self.setMinimumWidth(350)

        # --- Widgets ---
        self.host_input = QtWidgets.QLineEdit("localhost")
        self.port_input = QtWidgets.QLineEdit("5432")
        self.db_input = QtWidgets.QLineEdit("odoo_database")  # Example default
        self.user_input = QtWidgets.QLineEdit("odoo_user")  # Example default
        self.password_input = QtWidgets.QLineEdit()
        self.password_input.setEchoMode(QtWidgets.QLineEdit.EchoMode.Password)

        # --- Layout ---
        form_layout = QtWidgets.QFormLayout()
        form_layout.addRow("Host:", self.host_input)
        form_layout.addRow("Port:", self.port_input)
        form_layout.addRow("Database:", self.db_input)
        form_layout.addRow("User:", self.user_input)
        form_layout.addRow("Password:", self.password_input)

        # --- Buttons ---
        # Standard buttons for dialogs (OK, Cancel)
        button_box = QtWidgets.QDialogButtonBox(
            QtWidgets.QDialogButtonBox.StandardButton.Ok
            | QtWidgets.QDialogButtonBox.StandardButton.Cancel
        )
        button_box.accepted.connect(self.accept)  # Connect Ok signal to accept slot
        button_box.rejected.connect(self.reject)  # Connect Cancel signal to reject slot

        # Rename OK button to "Connect" for clarity
        button_box.button(QtWidgets.QDialogButtonBox.StandardButton.Ok).setText(
            "Connect"
        )

        # --- Main Layout ---
        main_layout = QtWidgets.QVBoxLayout(self)
        main_layout.addLayout(form_layout)
        main_layout.addWidget(button_box)
        self.setLayout(main_layout)

    def get_connection_details(self):
        """
        Retrieves the connection details entered by the user.

        Returns:
            dict: A dictionary containing the connection parameters.
        """
        return {
            "host": self.host_input.text().strip(),
            "port": self.port_input.text().strip(),
            "dbname": self.db_input.text().strip(),
            "user": self.user_input.text().strip(),
            "password": self.password_input.text(),  # Don't strip password
        }

    # Override accept to add basic validation (optional but good)
    def accept(self):
        """Validates input before accepting the dialog."""
        details = self.get_connection_details()
        if not all(
            [details["host"], details["port"], details["dbname"], details["user"]]
        ):
            QtWidgets.QMessageBox.warning(
                self,
                "Missing Information",
                "Please fill in Host, Port, Database, and User fields.",
            )
            return  # Stay on the dialog

        # Basic port validation
        try:
            port_num = int(details["port"])
            if not (0 < port_num < 65536):
                raise ValueError("Port number out of range")
        except ValueError:
            QtWidgets.QMessageBox.warning(
                self, "Invalid Port", "Please enter a valid port number (1-65535)."
            )
            self.port_input.setFocus()  # Focus the port input
            self.port_input.selectAll()
            return  # Stay on the dialog

        # If validation passes, call the original accept method
        super().accept()


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/widgets/results_view.py ==========
from PySide6 import QtWidgets, QtCore, QtGui
import csv
import io


class ResultsView(QtWidgets.QWidget):
    """
    Widget for displaying SQL query results.
    """

    def __init__(self, parent=None):
        super().__init__(parent)

        # Create layout
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Create toolbar
        toolbar = QtWidgets.QToolBar()
        layout.addWidget(toolbar)

        # Export action
        export_action = QtGui.QAction("Export to CSV", self)
        export_action.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_DialogSaveButton)
        )
        export_action.triggered.connect(self.export_to_csv)
        toolbar.addAction(export_action)

        # Copy action
        copy_action = QtGui.QAction("Copy Selection", self)
        copy_action.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_DialogSaveButton)
        )
        copy_action.setShortcut("Ctrl+C")
        copy_action.triggered.connect(self.copy_selection)
        toolbar.addAction(copy_action)

        # Clear action
        clear_action = QtGui.QAction("Clear Results", self)
        clear_action.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_DialogResetButton)
        )
        clear_action.triggered.connect(self.clear_results)
        toolbar.addAction(clear_action)

        # Add table view
        self.table_view = QtWidgets.QTableView()
        self.table_view.setAlternatingRowColors(True)
        self.table_view.setSortingEnabled(True)
        self.table_view.setSelectionBehavior(QtWidgets.QAbstractItemView.SelectRows)
        self.table_view.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.table_view.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.table_view.customContextMenuRequested.connect(self.show_context_menu)

        # Create model
        self.model = QtGui.QStandardItemModel()
        self.table_view.setModel(self.model)

        layout.addWidget(self.table_view)

        # Add status bar
        self.status_bar = QtWidgets.QStatusBar()
        self.status_bar.showMessage("No results")
        layout.addWidget(self.status_bar)

    def display_results(self, columns, data):
        """
        Display the query results.

        Args:
            columns (list): List of column names
            data (list): List of result rows (each row is a tuple of values)
        """
        # Clear previous results
        self.model.clear()

        if not columns:
            self.status_bar.showMessage("No results")
            return

        # Set column headers
        self.model.setHorizontalHeaderLabels(columns)

        # Add data rows
        for row_index, row_data in enumerate(data):
            row_items = []
            for col_index, cell_value in enumerate(row_data):
                item = QtGui.QStandardItem()

                # Handle None values
                if cell_value is None:
                    item.setText("NULL")
                    item.setData(None, QtCore.Qt.UserRole)
                    # Gray out NULL values
                    item.setForeground(QtGui.QBrush(QtGui.QColor(150, 150, 150)))
                else:
                    # Convert all values to strings for display
                    text = str(cell_value)
                    item.setText(text)
                    item.setData(cell_value, QtCore.Qt.UserRole)

                row_items.append(item)

            self.model.appendRow(row_items)

        # Resize columns to contents
        self.table_view.resizeColumnsToContents()

        # Update status bar
        row_count = len(data)
        column_count = len(columns)
        self.status_bar.showMessage(f"{row_count} rows, {column_count} columns")

    def show_context_menu(self, position):
        """Show context menu for the results table."""
        menu = QtWidgets.QMenu()

        # Add actions
        copy_action = menu.addAction("Copy Selection")
        copy_action.triggered.connect(self.copy_selection)

        export_action = menu.addAction("Export to CSV")
        export_action.triggered.connect(self.export_to_csv)

        # Show menu
        menu.exec(self.table_view.viewport().mapToGlobal(position))

    def copy_selection(self):
        """Copy selected cells to clipboard."""
        selection = self.table_view.selectionModel()
        if not selection.hasSelection():
            return

        selected_indexes = selection.selectedIndexes()
        if not selected_indexes:
            return

        # Sort indexes by row, then column
        selected_indexes.sort(key=lambda idx: (idx.row(), idx.column()))

        # Find the minimum and maximum row and column
        min_row = min(index.row() for index in selected_indexes)
        max_row = max(index.row() for index in selected_indexes)
        min_col = min(index.column() for index in selected_indexes)
        max_col = max(index.column() for index in selected_indexes)

        # Create a string to hold the copied data
        text = ""

        # Iterate through rows and columns
        for row in range(min_row, max_row + 1):
            row_text = []
            for col in range(min_col, max_col + 1):
                index = self.model.index(row, col)
                if index in selected_indexes:
                    # Use the text directly from the model
                    data = self.model.data(index)
                    row_text.append(str(data) if data is not None else "")
                else:
                    # If this cell is not selected, add an empty string
                    row_text.append("")

            # Add row to text
            text += "\t".join(row_text) + "\n"

        # Remove the trailing newline
        if text.endswith("\n"):
            text = text[:-1]

        # Copy to clipboard
        clipboard = QtWidgets.QApplication.clipboard()
        clipboard.setText(text)

        # Update status bar
        self.status_bar.showMessage("Selection copied to clipboard")

    def export_to_csv(self):
        """Export the results to a CSV file."""
        if self.model.rowCount() == 0:
            self.status_bar.showMessage("No data to export")
            return

        # Open file dialog
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self, "Export to CSV", "", "CSV Files (*.csv);;All Files (*)"
        )

        if not file_path:
            return

        try:
            with open(file_path, "w", newline="") as file:
                writer = csv.writer(file)

                # Write header
                header = []
                for col in range(self.model.columnCount()):
                    header.append(self.model.headerData(col, QtCore.Qt.Horizontal))
                writer.writerow(header)

                # Write data
                for row in range(self.model.rowCount()):
                    row_data = []
                    for col in range(self.model.columnCount()):
                        item = self.model.index(row, col)
                        value = self.model.data(item, QtCore.Qt.DisplayRole)
                        if value == "NULL":  # Handle NULL display values
                            value = ""
                        row_data.append(value)
                    writer.writerow(row_data)

            self.status_bar.showMessage(f"Data exported to {file_path}")

        except Exception as e:
            QtWidgets.QMessageBox.critical(
                self, "Export Error", f"Failed to export data: {str(e)}"
            )

    def clear_results(self):
        """Clear the results table."""
        self.model.clear()
        self.status_bar.showMessage("No results")


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/widgets/visualization_view.py ==========
from PySide6 import QtWidgets, QtCore, QtGui
import matplotlib

matplotlib.use("Qt5Agg")
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT
from matplotlib.figure import Figure
import numpy as np
import pandas as pd
from datetime import datetime
import re
import seaborn as sns
import io
from pathlib import Path


class VisualizationView(QtWidgets.QWidget):
    """Widget for visualizing query results."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.data_df = None
        self.column_types = {}
        self.setup_ui()

    def setup_ui(self):
        """Set up the UI components."""
        main_layout = QtWidgets.QVBoxLayout(self)

        # Title
        title_label = QtWidgets.QLabel("Data Visualization")
        title_font = title_label.font()
        title_font.setPointSize(14)
        title_font.setBold(True)
        title_label.setFont(title_font)
        main_layout.addWidget(title_label)

        # Split view for options and chart
        splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        main_layout.addWidget(splitter)

        # Options panel (left side)
        options_widget = QtWidgets.QWidget()
        options_layout = QtWidgets.QVBoxLayout(options_widget)

        # Chart type selection
        chart_type_group = QtWidgets.QGroupBox("Chart Type")
        chart_type_layout = QtWidgets.QVBoxLayout()
        self.chart_type_combo = QtWidgets.QComboBox()
        self.chart_type_combo.addItems(
            [
                "Bar Chart",
                "Line Chart",
                "Scatter Plot",
                "Pie Chart",
                "Histogram",
                "Box Plot",
                "Heatmap",
                "Area Chart",
                "Violin Plot",
            ]
        )
        self.chart_type_combo.currentIndexChanged.connect(self.on_chart_type_changed)
        chart_type_layout.addWidget(self.chart_type_combo)
        chart_type_group.setLayout(chart_type_layout)
        options_layout.addWidget(chart_type_group)

        # Data columns selection
        data_columns_group = QtWidgets.QGroupBox("Data Columns")
        data_columns_layout = QtWidgets.QFormLayout()

        self.x_axis_combo = QtWidgets.QComboBox()
        self.x_axis_combo.currentIndexChanged.connect(self.update_chart)

        self.y_axis_combo = QtWidgets.QComboBox()
        self.y_axis_combo.currentIndexChanged.connect(self.update_chart)

        self.group_by_combo = QtWidgets.QComboBox()
        self.group_by_combo.addItem("None")
        self.group_by_combo.currentIndexChanged.connect(self.update_chart)

        data_columns_layout.addRow("X-Axis:", self.x_axis_combo)
        data_columns_layout.addRow("Y-Axis:", self.y_axis_combo)
        data_columns_layout.addRow("Group By:", self.group_by_combo)

        data_columns_group.setLayout(data_columns_layout)
        options_layout.addWidget(data_columns_group)

        # Chart options group
        chart_options_group = QtWidgets.QGroupBox("Chart Options")
        chart_options_layout = QtWidgets.QFormLayout()

        self.chart_title_input = QtWidgets.QLineEdit()
        self.chart_title_input.setPlaceholderText("Enter chart title")
        self.chart_title_input.textChanged.connect(self.update_chart)

        self.x_label_input = QtWidgets.QLineEdit()
        self.x_label_input.setPlaceholderText("X-Axis Label")
        self.x_label_input.textChanged.connect(self.update_chart)

        self.y_label_input = QtWidgets.QLineEdit()
        self.y_label_input.setPlaceholderText("Y-Axis Label")
        self.y_label_input.textChanged.connect(self.update_chart)

        # Color scheme dropdown
        self.color_scheme_combo = QtWidgets.QComboBox()
        self.color_scheme_combo.addItems(
            [
                "Default",
                "Viridis",
                "Plasma",
                "Inferno",
                "Magma",
                "Cividis",
                "Blues",
                "Greens",
                "Reds",
                "Purples",
                "Oranges",
            ]
        )
        self.color_scheme_combo.currentIndexChanged.connect(self.update_chart)

        chart_options_layout.addRow("Title:", self.chart_title_input)
        chart_options_layout.addRow("X Label:", self.x_label_input)
        chart_options_layout.addRow("Y Label:", self.y_label_input)
        chart_options_layout.addRow("Color Scheme:", self.color_scheme_combo)

        chart_options_group.setLayout(chart_options_layout)
        options_layout.addWidget(chart_options_group)

        # Chart-specific options (these will be shown/hidden based on chart type)
        self.chart_specific_options = QtWidgets.QStackedWidget()

        # Bar chart options
        bar_options = QtWidgets.QWidget()
        bar_layout = QtWidgets.QFormLayout(bar_options)

        self.bar_orientation_combo = QtWidgets.QComboBox()
        self.bar_orientation_combo.addItems(["Vertical", "Horizontal"])
        self.bar_orientation_combo.currentIndexChanged.connect(self.update_chart)

        self.bar_width_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.bar_width_slider.setRange(1, 100)
        self.bar_width_slider.setValue(80)
        self.bar_width_slider.setTickPosition(QtWidgets.QSlider.TicksBelow)
        self.bar_width_slider.valueChanged.connect(self.update_chart)

        bar_layout.addRow("Orientation:", self.bar_orientation_combo)
        bar_layout.addRow("Bar Width:", self.bar_width_slider)

        self.chart_specific_options.addWidget(bar_options)

        # Line chart options
        line_options = QtWidgets.QWidget()
        line_layout = QtWidgets.QFormLayout(line_options)

        self.line_style_combo = QtWidgets.QComboBox()
        self.line_style_combo.addItems(["Solid", "Dashed", "Dotted", "Dash-Dot"])
        self.line_style_combo.currentIndexChanged.connect(self.update_chart)

        self.line_marker_combo = QtWidgets.QComboBox()
        self.line_marker_combo.addItems(
            ["None", "Circle", "Square", "Triangle", "Star", "Plus", "X"]
        )
        self.line_marker_combo.currentIndexChanged.connect(self.update_chart)

        self.line_width_spinner = QtWidgets.QSpinBox()
        self.line_width_spinner.setRange(1, 10)
        self.line_width_spinner.setValue(2)
        self.line_width_spinner.valueChanged.connect(self.update_chart)

        line_layout.addRow("Line Style:", self.line_style_combo)
        line_layout.addRow("Markers:", self.line_marker_combo)
        line_layout.addRow("Line Width:", self.line_width_spinner)

        self.chart_specific_options.addWidget(line_options)

        # Scatter plot options
        scatter_options = QtWidgets.QWidget()
        scatter_layout = QtWidgets.QFormLayout(scatter_options)

        self.scatter_size_spinner = QtWidgets.QSpinBox()
        self.scatter_size_spinner.setRange(5, 500)
        self.scatter_size_spinner.setValue(50)
        self.scatter_size_spinner.valueChanged.connect(self.update_chart)

        self.scatter_alpha_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.scatter_alpha_slider.setRange(0, 100)
        self.scatter_alpha_slider.setValue(70)
        self.scatter_alpha_slider.valueChanged.connect(self.update_chart)

        scatter_layout.addRow("Point Size:", self.scatter_size_spinner)
        scatter_layout.addRow("Transparency:", self.scatter_alpha_slider)

        self.chart_specific_options.addWidget(scatter_options)

        # Pie chart options
        pie_options = QtWidgets.QWidget()
        pie_layout = QtWidgets.QFormLayout(pie_options)

        self.pie_autopct_combo = QtWidgets.QComboBox()
        self.pie_autopct_combo.addItems(["None", "Percentage", "Value", "Both"])
        self.pie_autopct_combo.currentIndexChanged.connect(self.update_chart)

        self.pie_explode_check = QtWidgets.QCheckBox("Explode Largest Slice")
        self.pie_explode_check.stateChanged.connect(self.update_chart)

        self.pie_start_angle_spinner = QtWidgets.QSpinBox()
        self.pie_start_angle_spinner.setRange(0, 359)
        self.pie_start_angle_spinner.setValue(0)
        self.pie_start_angle_spinner.valueChanged.connect(self.update_chart)

        pie_layout.addRow("Labels:", self.pie_autopct_combo)
        pie_layout.addRow("", self.pie_explode_check)
        pie_layout.addRow("Start Angle:", self.pie_start_angle_spinner)

        self.chart_specific_options.addWidget(pie_options)

        # Histogram options
        histogram_options = QtWidgets.QWidget()
        histogram_layout = QtWidgets.QFormLayout(histogram_options)

        self.histogram_bins_spinner = QtWidgets.QSpinBox()
        self.histogram_bins_spinner.setRange(2, 100)
        self.histogram_bins_spinner.setValue(10)
        self.histogram_bins_spinner.valueChanged.connect(self.update_chart)

        self.histogram_kde_check = QtWidgets.QCheckBox("Show Density Curve")
        self.histogram_kde_check.stateChanged.connect(self.update_chart)

        histogram_layout.addRow("Bins:", self.histogram_bins_spinner)
        histogram_layout.addRow("", self.histogram_kde_check)

        self.chart_specific_options.addWidget(histogram_options)

        # Box plot options
        boxplot_options = QtWidgets.QWidget()
        boxplot_layout = QtWidgets.QFormLayout(boxplot_options)

        self.boxplot_notch_check = QtWidgets.QCheckBox("Show Notches")
        self.boxplot_notch_check.stateChanged.connect(self.update_chart)

        self.boxplot_orientation_combo = QtWidgets.QComboBox()
        self.boxplot_orientation_combo.addItems(["Vertical", "Horizontal"])
        self.boxplot_orientation_combo.currentIndexChanged.connect(self.update_chart)

        boxplot_layout.addRow("", self.boxplot_notch_check)
        boxplot_layout.addRow("Orientation:", self.boxplot_orientation_combo)

        self.chart_specific_options.addWidget(boxplot_options)

        # Heatmap options
        heatmap_options = QtWidgets.QWidget()
        heatmap_layout = QtWidgets.QFormLayout(heatmap_options)

        self.heatmap_annot_check = QtWidgets.QCheckBox("Show Values")
        self.heatmap_annot_check.setChecked(True)
        self.heatmap_annot_check.stateChanged.connect(self.update_chart)

        self.heatmap_cmap_combo = QtWidgets.QComboBox()
        self.heatmap_cmap_combo.addItems(
            [
                "Viridis",
                "Plasma",
                "Inferno",
                "Magma",
                "Cividis",
                "Blues",
                "Greens",
                "Reds",
                "Purples",
                "Oranges",
                "YlOrRd",
                "YlGnBu",
            ]
        )
        self.heatmap_cmap_combo.currentIndexChanged.connect(self.update_chart)

        heatmap_layout.addRow("", self.heatmap_annot_check)
        heatmap_layout.addRow("Color Map:", self.heatmap_cmap_combo)

        self.chart_specific_options.addWidget(heatmap_options)

        # Area chart options
        area_options = QtWidgets.QWidget()
        area_layout = QtWidgets.QFormLayout(area_options)

        self.area_alpha_slider = QtWidgets.QSlider(QtCore.Qt.Horizontal)
        self.area_alpha_slider.setRange(0, 100)
        self.area_alpha_slider.setValue(60)
        self.area_alpha_slider.valueChanged.connect(self.update_chart)

        self.area_stacked_check = QtWidgets.QCheckBox("Stacked Areas")
        self.area_stacked_check.stateChanged.connect(self.update_chart)

        area_layout.addRow("Transparency:", self.area_alpha_slider)
        area_layout.addRow("", self.area_stacked_check)

        self.chart_specific_options.addWidget(area_options)

        # Violin plot options
        violin_options = QtWidgets.QWidget()
        violin_layout = QtWidgets.QFormLayout(violin_options)

        self.violin_inner_combo = QtWidgets.QComboBox()
        self.violin_inner_combo.addItems(["Box", "Quartile", "Point", "Stick", "None"])
        self.violin_inner_combo.currentIndexChanged.connect(self.update_chart)

        self.violin_orientation_combo = QtWidgets.QComboBox()
        self.violin_orientation_combo.addItems(["Vertical", "Horizontal"])
        self.violin_orientation_combo.currentIndexChanged.connect(self.update_chart)

        violin_layout.addRow("Inner:", self.violin_inner_combo)
        violin_layout.addRow("Orientation:", self.violin_orientation_combo)

        self.chart_specific_options.addWidget(violin_options)

        options_layout.addWidget(self.chart_specific_options)

        # Export options
        export_group = QtWidgets.QGroupBox("Export")
        export_layout = QtWidgets.QVBoxLayout()

        self.export_button = QtWidgets.QPushButton("Export Chart")
        self.export_button.clicked.connect(self.export_chart)
        export_layout.addWidget(self.export_button)

        export_group.setLayout(export_layout)
        options_layout.addWidget(export_group)

        # Add stretch to push everything to the top
        options_layout.addStretch()

        # Chart view (right side)
        self.chart_widget = QtWidgets.QWidget()
        self.chart_layout = QtWidgets.QVBoxLayout(self.chart_widget)

        # Add placeholder for when no data is available
        self.placeholder_label = QtWidgets.QLabel(
            "No data to visualize. Run a query first."
        )
        self.placeholder_label.setAlignment(QtCore.Qt.AlignCenter)
        placeholder_font = self.placeholder_label.font()
        placeholder_font.setPointSize(14)
        self.placeholder_label.setFont(placeholder_font)
        self.chart_layout.addWidget(self.placeholder_label)

        # Add widgets to splitter
        splitter.addWidget(options_widget)
        splitter.addWidget(self.chart_widget)

        # Set initial splitter sizes (30% options, 70% chart)
        splitter.setSizes([300, 700])

        # Set the initial chart type
        self.on_chart_type_changed(0)

        # Status bar for error messages
        self.status_bar = QtWidgets.QStatusBar()
        main_layout.addWidget(self.status_bar)

    def on_chart_type_changed(self, index):
        """Show the appropriate options for the selected chart type."""
        self.chart_specific_options.setCurrentIndex(index)
        self.update_chart()

    def set_data(self, columns, data):
        """Set the data to visualize."""
        if not columns or not data:
            # Clear the current visualization if there's no data
            self.data_df = None
            self.clear_chart()
            self.placeholder_label.setVisible(True)
            return

        # Convert to pandas DataFrame for easier manipulation
        self.data_df = pd.DataFrame(data, columns=columns)

        # Remove the placeholder
        self.placeholder_label.setVisible(False)

        # Determine column types (numeric, date, categorical, etc.)
        self.infer_column_types()

        # Update column selectors
        self.update_column_selectors()

        # Update the chart
        self.update_chart()

    def infer_column_types(self):
        """Infer data types for each column."""
        self.column_types = {}
        if self.data_df is None:
            return

        for column in self.data_df.columns:
            # Check if column is numeric
            if pd.api.types.is_numeric_dtype(self.data_df[column]):
                self.column_types[column] = "numeric"
            else:
                # Check if column contains dates
                try:
                    # Try to convert a sample to datetime
                    sample = (
                        self.data_df[column].dropna().iloc[0]
                        if not self.data_df[column].dropna().empty
                        else None
                    )
                    if sample and isinstance(sample, str):
                        datetime.strptime(sample, "%Y-%m-%d")
                        self.column_types[column] = "date"
                    else:
                        self.column_types[column] = "categorical"
                except (ValueError, TypeError):
                    # If conversion fails, consider it categorical
                    self.column_types[column] = "categorical"

    def update_column_selectors(self):
        """Update column selector dropdown options based on available data."""
        if self.data_df is None:
            return

        # Store current selections
        x_current = (
            self.x_axis_combo.currentText() if self.x_axis_combo.count() > 0 else ""
        )
        y_current = (
            self.y_axis_combo.currentText() if self.y_axis_combo.count() > 0 else ""
        )
        group_current = (
            self.group_by_combo.currentText() if self.group_by_combo.count() > 0 else ""
        )

        # Temporarily block signals to prevent chart updates during changes
        self.x_axis_combo.blockSignals(True)
        self.y_axis_combo.blockSignals(True)
        self.group_by_combo.blockSignals(True)

        # Clear current options
        self.x_axis_combo.clear()
        self.y_axis_combo.clear()
        self.group_by_combo.clear()
        self.group_by_combo.addItem("None")

        # Populate with current columns
        for column in self.data_df.columns:
            self.x_axis_combo.addItem(column)
            self.y_axis_combo.addItem(column)
            self.group_by_combo.addItem(column)

        # Restore previous selections if they still exist
        if x_current and self.x_axis_combo.findText(x_current) >= 0:
            self.x_axis_combo.setCurrentText(x_current)
        elif self.x_axis_combo.count() > 0:
            # Set default X axis based on column types - prefer categorical or date for x-axis
            for col, col_type in self.column_types.items():
                if col_type in ("categorical", "date"):
                    self.x_axis_combo.setCurrentText(col)
                    break

        if y_current and self.y_axis_combo.findText(y_current) >= 0:
            self.y_axis_combo.setCurrentText(y_current)
        elif self.y_axis_combo.count() > 0:
            # Set default Y axis - prefer numeric
            for col, col_type in self.column_types.items():
                if col_type == "numeric":
                    self.y_axis_combo.setCurrentText(col)
                    break

        if group_current and self.group_by_combo.findText(group_current) >= 0:
            self.group_by_combo.setCurrentText(group_current)

        # Unblock signals
        self.x_axis_combo.blockSignals(False)
        self.y_axis_combo.blockSignals(False)
        self.group_by_combo.blockSignals(False)

        # Set default chart title and axis labels
        if self.x_axis_combo.count() > 0 and self.y_axis_combo.count() > 0:
            x_col = self.x_axis_combo.currentText()
            y_col = self.y_axis_combo.currentText()

            self.chart_title_input.setText(f"{y_col} by {x_col}")
            self.x_label_input.setText(x_col)
            self.y_label_input.setText(y_col)

    def clear_chart(self):
        """Clear the current chart."""
        # Remove all widgets from the chart layout
        while self.chart_layout.count():
            item = self.chart_layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

    def update_chart(self):
        """Update the chart based on current settings."""
        if self.data_df is None or self.data_df.empty:
            self.status_bar.showMessage("No data available")
            return

        # Clear previous chart
        self.clear_chart()

        try:
            # Get chart settings
            chart_type = self.chart_type_combo.currentText()

            if self.x_axis_combo.count() == 0 or self.y_axis_combo.count() == 0:
                self.status_bar.showMessage(
                    "Not enough columns available for visualization"
                )
                return

            x_col = self.x_axis_combo.currentText()
            y_col = self.y_axis_combo.currentText()

            group_col = self.group_by_combo.currentText()
            if group_col == "None":
                group_col = None

            # Create matplotlib figure
            fig = Figure(figsize=(8, 6), dpi=100, tight_layout=True)
            canvas = FigureCanvasQTAgg(fig)
            ax = fig.add_subplot(111)

            # Apply seaborn styling
            sns.set_style("whitegrid")

            # Get color palette
            color_scheme = self.color_scheme_combo.currentText()
            if color_scheme != "Default":
                palette = color_scheme.lower()
            else:
                palette = None

            # Create the appropriate chart type
            if chart_type == "Bar Chart":
                self.create_bar_chart(fig, ax, x_col, y_col, group_col, palette)
            elif chart_type == "Line Chart":
                self.create_line_chart(fig, ax, x_col, y_col, group_col, palette)
            elif chart_type == "Scatter Plot":
                self.create_scatter_plot(fig, ax, x_col, y_col, group_col, palette)
            elif chart_type == "Pie Chart":
                self.create_pie_chart(fig, ax, x_col, y_col, palette)
            elif chart_type == "Histogram":
                self.create_histogram(fig, ax, x_col, y_col, group_col, palette)
            elif chart_type == "Box Plot":
                self.create_box_plot(fig, ax, x_col, y_col, group_col, palette)
            elif chart_type == "Heatmap":
                self.create_heatmap(fig, ax, palette)
            elif chart_type == "Area Chart":
                self.create_area_chart(fig, ax, x_col, y_col, group_col, palette)
            elif chart_type == "Violin Plot":
                self.create_violin_plot(fig, ax, x_col, y_col, group_col, palette)

            # Apply titles and labels
            title = self.chart_title_input.text()
            if title:
                ax.set_title(title, fontsize=14)

            x_label = self.x_label_input.text()
            if x_label and chart_type != "Pie Chart":
                ax.set_xlabel(x_label, fontsize=12)

            y_label = self.y_label_input.text()
            if y_label and chart_type != "Pie Chart":
                ax.set_ylabel(y_label, fontsize=12)

            # Add the toolbar for zooming, panning, saving, etc.
            toolbar = NavigationToolbar2QT(canvas, self)

            # Add the canvas and toolbar to the layout
            self.chart_layout.addWidget(toolbar)
            self.chart_layout.addWidget(canvas)

            self.status_bar.showMessage("Chart updated successfully")

        except Exception as e:
            self.status_bar.showMessage(f"Error creating chart: {str(e)}")
            # Add a label with the error message to the chart area
            error_label = QtWidgets.QLabel(f"Error creating chart:\n{str(e)}")
            error_label.setAlignment(QtCore.Qt.AlignCenter)
            error_label.setStyleSheet("color: red;")
            self.chart_layout.addWidget(error_label)

    def create_bar_chart(self, fig, ax, x_col, y_col, group_col, palette):
        """Create a bar chart."""
        # Get bar chart options
        orientation = self.bar_orientation_combo.currentText()
        bar_width = (
            self.bar_width_slider.value() / 100.0
        )  # Convert slider value to proportion

        df = self.data_df.copy()

        # Group by x-axis if needed
        if df[x_col].nunique() > 100:  # If too many categories
            self.status_bar.showMessage("Warning: Too many categories. Showing top 20.")
            # Get counts and take top categories
            value_counts = df[x_col].value_counts().nlargest(20)
            # Filter to keep only these categories
            df = df[df[x_col].isin(value_counts.index)]

        if group_col:
            # Group data for a grouped bar chart
            grouped = df.groupby([x_col, group_col])[y_col].mean().unstack()
            if orientation == "Horizontal":
                grouped.plot(kind="barh", ax=ax, width=bar_width, colormap=palette)
            else:
                grouped.plot(kind="bar", ax=ax, width=bar_width, colormap=palette)
        else:
            # Simple bar chart
            grouped = df.groupby(x_col)[y_col].mean()
            if orientation == "Horizontal":
                grouped.plot(
                    kind="barh",
                    ax=ax,
                    width=bar_width,
                    color=sns.color_palette(palette, 1)[0],
                )
            else:
                grouped.plot(
                    kind="bar",
                    ax=ax,
                    width=bar_width,
                    color=sns.color_palette(palette, 1)[0],
                )

        # Rotate x-axis labels if vertical bars
        if orientation == "Vertical" and len(grouped) > 5:
            plt = fig.canvas.manager.canvas.figure.gca()
            plt.tick_params(axis="x", rotation=45)

        if group_col:
            ax.legend(title=group_col)

        # Adjustments for better appearance
        ax.set_axisbelow(True)  # Put grid behind bars

    def create_line_chart(self, fig, ax, x_col, y_col, group_col, palette):
        """Create a line chart."""
        # Get line chart options
        line_style = self.line_style_combo.currentText().lower()
        marker = self.line_marker_combo.currentText()
        line_width = self.line_width_spinner.value()

        # Map line styles
        line_styles = {"solid": "-", "dashed": "--", "dotted": ":", "dash-dot": "-."}

        # Map markers
        markers = {
            "none": "",
            "circle": "o",
            "square": "s",
            "triangle": "^",
            "star": "*",
            "plus": "+",
            "x": "x",
        }

        df = self.data_df.copy()

        # Check if x column could be a date
        if self.column_types.get(x_col) == "date":
            try:
                df[x_col] = pd.to_datetime(df[x_col])
                df = df.sort_values(by=x_col)
            except:
                pass

        # Sort by x-axis values if numeric
        elif self.column_types.get(x_col) == "numeric":
            df = df.sort_values(by=x_col)

        if group_col:
            # Create a line for each group
            for name, group in df.groupby(group_col):
                ax.plot(
                    group[x_col],
                    group[y_col],
                    label=name,
                    linestyle=line_styles.get(line_style, "-"),
                    marker=markers.get(marker, ""),
                    linewidth=line_width,
                )
            ax.legend(title=group_col)
        else:
            # Simple line chart
            ax.plot(
                df[x_col],
                df[y_col],
                linestyle=line_styles.get(line_style, "-"),
                marker=markers.get(marker, ""),
                linewidth=line_width,
                color=sns.color_palette(palette, 1)[0],
            )

        # Rotate x-axis labels if many categories
        if df[x_col].nunique() > 5:
            plt = fig.canvas.manager.canvas.figure.gca()
            plt.tick_params(axis="x", rotation=45)

    def create_scatter_plot(self, fig, ax, x_col, y_col, group_col, palette):
        """Create a scatter plot."""
        # Get scatter plot options
        point_size = self.scatter_size_spinner.value()
        alpha = self.scatter_alpha_slider.value() / 100.0  # Convert to proportion

        df = self.data_df.copy()

        # Ensure x and y are numeric
        if not pd.api.types.is_numeric_dtype(
            df[x_col]
        ) or not pd.api.types.is_numeric_dtype(df[y_col]):
            self.status_bar.showMessage(
                "Warning: Non-numeric columns converted for scatter plot"
            )
            # Convert non-numeric columns
            for col in [x_col, y_col]:
                if not pd.api.types.is_numeric_dtype(df[col]):
                    if len(df[col].unique()) <= 20:  # If not too many categories
                        # Map categories to numbers
                        categories = df[col].unique()
                        mapping = {cat: i for i, cat in enumerate(categories)}
                        df[col] = df[col].map(mapping)
                    else:
                        # Too many categories, use rank
                        df[col] = df[col].rank()

        if group_col:
            # Create a scatter for each group with different colors
            for name, group in df.groupby(group_col):
                ax.scatter(
                    group[x_col], group[y_col], s=point_size, alpha=alpha, label=name
                )
            ax.legend(title=group_col)
        else:
            # Simple scatter plot
            scatter = ax.scatter(
                df[x_col],
                df[y_col],
                s=point_size,
                alpha=alpha,
                color=sns.color_palette(palette, 1)[0],
            )

    def create_pie_chart(self, fig, ax, x_col, y_col, palette):
        """Create a pie chart."""
        # Get pie chart options
        autopct = self.pie_autopct_combo.currentText()
        explode_largest = self.pie_explode_check.isChecked()
        start_angle = self.pie_start_angle_spinner.value()

        # Map autopct options
        if autopct == "None":
            autopct_fmt = None
        elif autopct == "Percentage":
            autopct_fmt = "%1.1f%%"
        elif autopct == "Value":
            autopct_fmt = lambda p: "{:.0f}".format(p * sum(sizes) / 100)
        else:  # Both
            autopct_fmt = lambda p: "{:.0f} ({:.1f}%)".format(p * sum(sizes) / 100, p)

        df = self.data_df.copy()

        # Group by x-axis and aggregate y-axis
        grouped = df.groupby(x_col)[y_col].sum()

        # Limit to top 10 categories if too many
        if len(grouped) > 10:
            self.status_bar.showMessage("Warning: Too many categories. Showing top 10.")
            grouped = grouped.nlargest(10)

        # Get labels and sizes
        labels = grouped.index.tolist()
        sizes = grouped.values.tolist()

        # Create explode values if needed
        explode = None
        if explode_largest:
            explode = [0] * len(sizes)
            largest_idx = sizes.index(max(sizes))
            explode[largest_idx] = 0.1

        # Create pie chart
        wedges, texts, autotexts = ax.pie(
            sizes,
            labels=labels,
            autopct=autopct_fmt,
            explode=explode,
            startangle=start_angle,
            shadow=True,
            colors=sns.color_palette(palette, len(sizes)),
        )

        # Equal aspect ratio ensures pie is drawn as a circle
        ax.axis("equal")

        # Format text labels if they exist
        if autopct_fmt:
            for autotext in autotexts:
                autotext.set_fontsize(9)

        # Shrink text if many categories
        if len(labels) > 5:
            for text in texts:
                text.set_fontsize(8)

    def create_histogram(self, fig, ax, x_col, y_col, group_col, palette):
        """Create a histogram."""
        # Get histogram options
        bins = self.histogram_bins_spinner.value()
        kde = self.histogram_kde_check.isChecked()

        df = self.data_df.copy()

        # For histogram, we primarily care about the x-axis
        # y-axis is ignored for simple histograms

        if group_col:
            # Create histogram for each group
            for name, group in df.groupby(group_col):
                sns.histplot(
                    data=group,
                    x=x_col,
                    bins=bins,
                    kde=kde,
                    ax=ax,
                    label=name,
                    alpha=0.6,
                )
            ax.legend(title=group_col)
        else:
            # Simple histogram
            sns.histplot(
                data=df,
                x=x_col,
                bins=bins,
                kde=kde,
                ax=ax,
                color=sns.color_palette(palette, 1)[0],
            )

    def create_box_plot(self, fig, ax, x_col, y_col, group_col, palette):
        """Create a box plot."""
        # Get box plot options
        notch = self.boxplot_notch_check.isChecked()
        orientation = self.boxplot_orientation_combo.currentText().lower()

        df = self.data_df.copy()

        # Determine x and y based on orientation
        if orientation == "horizontal":
            plot_x = y_col
            plot_y = x_col
        else:
            plot_x = x_col
            plot_y = y_col

        # Create box plot
        if group_col:
            sns.boxplot(
                data=df,
                x=plot_x,
                y=plot_y,
                hue=group_col,
                notch=notch,
                palette=palette,
                ax=ax,
            )
            # Move legend outside if many groups
            if df[group_col].nunique() > 4:
                ax.legend(title=group_col, bbox_to_anchor=(1.05, 1), loc="upper left")
        else:
            sns.boxplot(
                data=df, x=plot_x, y=plot_y, notch=notch, palette=palette, ax=ax
            )

        # Add grid lines for better readability
        ax.grid(True, linestyle="--", alpha=0.7)

    def create_heatmap(self, fig, ax, palette):
        """Create a correlation heatmap."""
        # Get heatmap options
        show_values = self.heatmap_annot_check.isChecked()
        cmap = self.heatmap_cmap_combo.currentText().lower()

        df = self.data_df.copy()

        # Select only numeric columns for correlation
        numeric_df = df.select_dtypes(include=["number"])

        if numeric_df.shape[1] < 2:
            self.status_bar.showMessage("Error: Not enough numeric columns for heatmap")
            ax.text(
                0.5,
                0.5,
                "Not enough numeric columns for correlation analysis",
                horizontalalignment="center",
                verticalalignment="center",
                transform=ax.transAxes,
                fontsize=12,
            )
            return

        # Calculate correlation matrix
        corr_matrix = numeric_df.corr()

        # Create heatmap
        sns.heatmap(
            corr_matrix,
            annot=show_values,
            fmt=".2f",
            cmap=cmap,
            ax=ax,
            vmin=-1,
            vmax=1,
            center=0,
            square=True,
            linewidths=0.5,
        )

        # Rotate axis labels if many columns
        if numeric_df.shape[1] > 5:
            ax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha="right")
            ax.set_yticklabels(ax.get_yticklabels(), rotation=0)

        # Set title
        ax.set_title("Correlation Matrix", fontsize=14)

    def create_area_chart(self, fig, ax, x_col, y_col, group_col, palette):
        """Create an area chart."""
        # Get area chart options
        alpha = self.area_alpha_slider.value() / 100.0  # Convert to proportion
        stacked = self.area_stacked_check.isChecked()

        df = self.data_df.copy()

        # Check if x column could be a date
        if self.column_types.get(x_col) == "date":
            try:
                df[x_col] = pd.to_datetime(df[x_col])
                df = df.sort_values(by=x_col)
            except:
                pass
        # Sort by x-axis values if numeric
        elif self.column_types.get(x_col) == "numeric":
            df = df.sort_values(by=x_col)

        if group_col:
            # Pivot data for area chart
            pivot_df = df.pivot_table(
                index=x_col, columns=group_col, values=y_col, aggfunc="mean"
            )

            # Fill NAs with zeros
            pivot_df = pivot_df.fillna(0)

            # Plot area chart
            pivot_df.plot(
                kind="area", stacked=stacked, alpha=alpha, ax=ax, colormap=palette
            )

            # Add legend
            ax.legend(title=group_col)
        else:
            # For non-grouped area chart, we need to aggregate if there are duplicate x values
            grouped = df.groupby(x_col)[y_col].mean()
            grouped.plot(
                kind="area", alpha=alpha, ax=ax, color=sns.color_palette(palette, 1)[0]
            )

        # Rotate x-axis labels if many
        if df[x_col].nunique() > 5:
            ax.tick_params(axis="x", rotation=45)

    def create_violin_plot(self, fig, ax, x_col, y_col, group_col, palette):
        """Create a violin plot."""
        # Get violin plot options
        inner = self.violin_inner_combo.currentText().lower()
        orientation = self.violin_orientation_combo.currentText().lower()

        df = self.data_df.copy()

        # Determine x and y based on orientation
        if orientation == "horizontal":
            plot_x = y_col
            plot_y = x_col
        else:
            plot_x = x_col
            plot_y = y_col

        # Create violin plot
        if group_col:
            sns.violinplot(
                data=df,
                x=plot_x,
                y=plot_y,
                hue=group_col,
                inner=inner,
                palette=palette,
                ax=ax,
            )
            # Move legend outside if many groups
            if df[group_col].nunique() > 4:
                ax.legend(title=group_col, bbox_to_anchor=(1.05, 1), loc="upper left")
        else:
            sns.violinplot(
                data=df, x=plot_x, y=plot_y, inner=inner, palette=palette, ax=ax
            )

        # Add grid lines for better readability
        ax.grid(True, linestyle="--", alpha=0.7)

    def export_chart(self):
        """Export the current chart to a file."""
        if not hasattr(self, "data_df") or self.data_df is None:
            self.status_bar.showMessage("No chart to export")
            return

        # Open file dialog
        file_path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self,
            "Export Chart",
            str(Path.home()),
            "PNG (*.png);;JPEG (*.jpg *.jpeg);;PDF (*.pdf);;SVG (*.svg);;All Files (*)",
        )

        if not file_path:
            return

        try:
            # Get the current figure from the canvas
            canvas_items = [
                item.widget()
                for item in self.chart_layout.children()
                if isinstance(item.widget(), FigureCanvasQTAgg)
            ]

            if not canvas_items:
                self.status_bar.showMessage("No chart to export")
                return

            # Get the first canvas
            canvas = canvas_items[0]
            fig = canvas.figure

            # Save the figure
            fig.savefig(file_path, dpi=300, bbox_inches="tight")

            self.status_bar.showMessage(f"Chart exported to {file_path}")

        except Exception as e:
            self.status_bar.showMessage(f"Error exporting chart: {str(e)}")
            QtWidgets.QMessageBox.critical(
                self, "Export Error", f"Failed to export chart:\n{str(e)}"
            )


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/widgets/query_editor.py ==========
from PySide6 import QtWidgets, QtCore, QtGui


class QueryEditor(QtWidgets.QWidget):
    """
    Widget for editing and executing SQL queries.
    """

    # Signal emitted when a query is executed
    queryExecuted = QtCore.Signal(list, list)  # columns, data

    def __init__(self, parent=None):
        super().__init__(parent)

        # Store database connection
        self.connection = None

        # Create layout
        layout = QtWidgets.QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Create toolbar
        toolbar = QtWidgets.QToolBar()
        layout.addWidget(toolbar)

        # Execute action
        self.execute_action = QtGui.QAction("Execute", self)
        self.execute_action.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_MediaPlay)
        )
        self.execute_action.setShortcut("F5")
        self.execute_action.setToolTip("Execute query (F5)")
        self.execute_action.triggered.connect(self.execute_query)
        toolbar.addAction(self.execute_action)

        # Clear action
        clear_action = QtGui.QAction("Clear", self)
        clear_action.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_DialogResetButton)
        )
        clear_action.triggered.connect(self.clear_query)
        toolbar.addAction(clear_action)

        toolbar.addSeparator()

        # History actions (placeholder)
        back_action = QtGui.QAction("Previous", self)
        back_action.setIcon(self.style().standardIcon(QtWidgets.QStyle.SP_ArrowLeft))
        back_action.setEnabled(False)  # Disabled until history is implemented
        toolbar.addAction(back_action)

        forward_action = QtGui.QAction("Next", self)
        forward_action.setIcon(
            self.style().standardIcon(QtWidgets.QStyle.SP_ArrowRight)
        )
        forward_action.setEnabled(False)  # Disabled until history is implemented
        toolbar.addAction(forward_action)

        # Add query editor
        self.editor = QtWidgets.QPlainTextEdit()
        self.editor.setPlaceholderText("Enter your SQL query here...")

        # Use a monospaced font
        font = QtGui.QFont("Courier New", 10)
        self.editor.setFont(font)

        # Add line numbers (optional enhancement)
        self.line_numbers = LineNumberArea(self.editor)
        self.editor.blockCountChanged.connect(self.update_line_number_area_width)
        self.editor.updateRequest.connect(self.update_line_number_area)
        self.update_line_number_area_width(0)

        layout.addWidget(self.editor)

        # Enable syntax highlighting (for a future enhancement)
        # self.highlighter = SQLHighlighter(self.editor.document())

        # Add status bar
        self.status_bar = QtWidgets.QStatusBar()
        self.status_bar.showMessage("Ready")
        layout.addWidget(self.status_bar)

        # Query history
        self.query_history = []
        self.history_position = -1

    def set_connection(self, connection):
        """Set the database connection."""
        self.connection = connection
        # Enable or disable execute button based on connection status
        self.execute_action.setEnabled(connection is not None)

    def execute_query(self):
        """Execute the current SQL query."""
        if not self.connection:
            self.status_bar.showMessage("Not connected to a database.")
            return

        # Get the query text
        query = self.editor.toPlainText().strip()
        if not query:
            self.status_bar.showMessage("No query to execute.")
            return

        # Add to history
        if not self.query_history or self.query_history[-1] != query:
            self.query_history.append(query)
            self.history_position = len(self.query_history) - 1

        # Update status
        self.status_bar.showMessage("Executing query...")

        try:
            cursor = self.connection.cursor()
            cursor.execute(query)

            # Check if the query returns results
            if cursor.description:
                # Get column names
                columns = [desc[0] for desc in cursor.description]

                # Fetch all data
                # Note: For large results, might want to limit rows or implement pagination
                data = cursor.fetchall()

                # Update status
                self.status_bar.showMessage(
                    f"Query executed successfully. Returned {len(data)} rows."
                )

                # Emit signal with results
                self.queryExecuted.emit(columns, data)
            else:
                # For queries that don't return data (INSERT, UPDATE, DELETE)
                affected = cursor.rowcount
                self.status_bar.showMessage(
                    f"Query executed successfully. Affected {affected} rows."
                )

                # Emit signal with empty results to clear the results view
                self.queryExecuted.emit([], [])

            cursor.close()

        except Exception as e:
            self.status_bar.showMessage(f"Error: {str(e)}")
            # Display error in a message box for better visibility
            QtWidgets.QMessageBox.critical(self, "Query Error", str(e))

    def clear_query(self):
        """Clear the query editor."""
        self.editor.clear()
        self.status_bar.showMessage("Ready")

    def insert_text(self, text):
        """Insert text at the current cursor position."""
        self.editor.insertPlainText(text)

    def update_line_number_area_width(self, count):
        """Update the width of the line number area."""
        width = self.line_numbers.calculate_width(self.editor.blockCount())
        self.editor.setViewportMargins(width, 0, 0, 0)

    def update_line_number_area(self, rect, dy):
        """Update the line number area."""
        if dy:
            self.line_numbers.scroll(0, dy)
        else:
            self.line_numbers.update(
                0, rect.y(), self.line_numbers.width(), rect.height()
            )

        if rect.contains(self.editor.viewport().rect()):
            self.update_line_number_area_width(0)


class LineNumberArea(QtWidgets.QWidget):
    """Widget for displaying line numbers in the query editor."""

    def __init__(self, editor):
        super().__init__(editor)
        self.editor = editor
        self.editor.installEventFilter(self)

    def calculate_width(self, count):
        """Calculate the width needed to display line numbers."""
        digits = len(str(max(1, count)))
        return 10 + self.editor.fontMetrics().horizontalAdvance("9") * digits

    def eventFilter(self, obj, event):
        """Handle resize events to update the line number area."""
        if obj is self.editor and event.type() == QtCore.QEvent.Resize:
            rect = self.editor.contentsRect()
            self.setGeometry(
                QtCore.QRect(
                    rect.left(),
                    rect.top(),
                    self.calculate_width(self.editor.blockCount()),
                    rect.height(),
                )
            )
        return super().eventFilter(obj, event)

    def paintEvent(self, event):
        """Paint the line numbers."""
        painter = QtGui.QPainter(self)
        painter.fillRect(event.rect(), QtGui.QColor(240, 240, 240))

        block = self.editor.firstVisibleBlock()
        block_number = block.blockNumber()
        top = int(
            self.editor.blockBoundingGeometry(block)
            .translated(self.editor.contentOffset())
            .top()
        )
        bottom = top + int(self.editor.blockBoundingRect(block).height())

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(block_number + 1)
                painter.setPen(QtGui.QColor(100, 100, 100))
                painter.drawText(
                    0,
                    top,
                    self.width() - 5,
                    self.editor.fontMetrics().height(),
                    QtCore.Qt.AlignRight,
                    number,
                )

            block = block.next()
            top = bottom
            bottom = top + int(self.editor.blockBoundingRect(block).height())
            block_number += 1


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/widgets/__init__.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/ui/widgets/schema_browser.py ==========
from PySide6 import QtWidgets, QtCore, QtGui


class SchemaBrowser(QtWidgets.QTreeWidget):
    """
    Tree widget for browsing database schemas, tables, and columns.
    """

    # Signal emitted when a table is double-clicked
    tableSelected = QtCore.Signal(str, str)  # schema_name, table_name
    queryGenerated = QtCore.Signal(str)  # Signal to emit generated queries

    def __init__(self, parent=None):
        super().__init__(parent)

        # Set properties
        self.setHeaderLabels(["Database Objects"])
        self.setAlternatingRowColors(True)
        self.setAnimated(True)

        # Connect signals
        self.itemExpanded.connect(self.on_item_expanded)
        self.itemDoubleClicked.connect(self.on_item_double_clicked)

        # Context menu
        self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_context_menu)

    def populate_schema(self, connection):
        """
        Populate the tree with schema information from the database.

        Args:
            connection: psycopg2 connection object
        """
        self.clear()
        self.connection = connection

        try:
            cursor = connection.cursor()

            # Get schemas
            cursor.execute("""
                SELECT schema_name 
                FROM information_schema.schemata 
                WHERE schema_name NOT LIKE 'pg_%' 
                AND schema_name != 'information_schema'
                ORDER BY schema_name
            """)

            schemas = cursor.fetchall()

            # For each schema
            for schema in schemas:
                schema_name = schema[0]
                schema_item = QtWidgets.QTreeWidgetItem(self, [schema_name])
                schema_item.setData(
                    0, QtCore.Qt.UserRole, {"type": "schema", "name": schema_name}
                )

                # Add a placeholder for tables
                placeholder = QtWidgets.QTreeWidgetItem(
                    schema_item, ["Loading tables..."]
                )
                schema_item.addChild(placeholder)

            cursor.close()

        except Exception as e:
            QtWidgets.QMessageBox.warning(
                self,
                "Error Loading Schema",
                f"Failed to load database schema:\n{str(e)}",
            )

    def on_item_expanded(self, item):
        """Load child items when a parent item is expanded."""
        item_data = item.data(0, QtCore.Qt.UserRole)
        if not item_data:
            return

        item_type = item_data.get("type")

        # If a schema is expanded, load its tables
        if (
            item_type == "schema"
            and item.childCount() == 1
            and item.child(0).text(0) == "Loading tables..."
        ):
            schema_name = item_data.get("name")
            self.load_tables(item, schema_name)

        # If a table is expanded, load its columns
        elif (
            item_type == "table"
            and item.childCount() == 1
            and item.child(0).text(0) == "Loading columns..."
        ):
            schema_name = item_data.get("schema")
            table_name = item_data.get("name")
            self.load_columns(item, schema_name, table_name)

    def load_tables(self, schema_item, schema_name):
        """Load tables for a schema."""
        try:
            # Remove placeholder
            schema_item.removeChild(schema_item.child(0))

            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = %s 
                AND table_type = 'BASE TABLE'
                ORDER BY table_name
            """,
                (schema_name,),
            )

            tables = cursor.fetchall()

            if not tables:
                no_tables = QtWidgets.QTreeWidgetItem(schema_item, ["No tables"])
                schema_item.addChild(no_tables)
                return

            # Add tables
            for table in tables:
                table_name = table[0]
                table_item = QtWidgets.QTreeWidgetItem(schema_item, [table_name])
                table_item.setData(
                    0,
                    QtCore.Qt.UserRole,
                    {"type": "table", "name": table_name, "schema": schema_name},
                )

                # Add placeholder for columns
                placeholder = QtWidgets.QTreeWidgetItem(
                    table_item, ["Loading columns..."]
                )
                table_item.addChild(placeholder)

            cursor.close()

        except Exception as e:
            QtWidgets.QMessageBox.warning(
                self,
                "Error Loading Tables",
                f"Failed to load tables for schema '{schema_name}':\n{str(e)}",
            )

    def load_columns(self, table_item, schema_name, table_name):
        """Load columns for a table."""
        try:
            # Remove placeholder
            table_item.removeChild(table_item.child(0))

            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT column_name, data_type, is_nullable
                FROM information_schema.columns
                WHERE table_schema = %s AND table_name = %s
                ORDER BY ordinal_position
            """,
                (schema_name, table_name),
            )

            columns = cursor.fetchall()

            if not columns:
                no_columns = QtWidgets.QTreeWidgetItem(table_item, ["No columns"])
                table_item.addChild(no_columns)
                return

            # Add columns
            for column in columns:
                column_name = column[0]
                data_type = column[1]
                is_nullable = "YES" if column[2] == "YES" else "NO"

                # Include data type and nullability in the display
                display_text = f"{column_name} ({data_type}, Nullable: {is_nullable})"

                column_item = QtWidgets.QTreeWidgetItem(table_item, [display_text])
                column_item.setData(
                    0,
                    QtCore.Qt.UserRole,
                    {
                        "type": "column",
                        "name": column_name,
                        "data_type": data_type,
                        "is_nullable": is_nullable,
                        "table": table_name,
                        "schema": schema_name,
                    },
                )

            cursor.close()

        except Exception as e:
            QtWidgets.QMessageBox.warning(
                self,
                "Error Loading Columns",
                f"Failed to load columns for table '{schema_name}.{table_name}':\n{str(e)}",
            )

    def on_item_double_clicked(self, item, column):
        """Handle double-click on an item."""
        item_data = item.data(0, QtCore.Qt.UserRole)
        if not item_data:
            return

        item_type = item_data.get("type")

        if item_type == "table":
            schema_name = item_data.get("schema")
            table_name = item_data.get("name")
            # Emit signal with schema and table name
            self.tableSelected.emit(schema_name, table_name)

    def show_context_menu(self, position):
        """Show context menu for tree items."""
        item = self.itemAt(position)
        if not item:
            return

        item_data = item.data(0, QtCore.Qt.UserRole)
        if not item_data:
            return

        item_type = item_data.get("type")

        menu = QtWidgets.QMenu()

        if item_type == "schema":
            schema_name = item_data.get("name")
            refresh_action = menu.addAction("Refresh Schema")
            refresh_action.triggered.connect(
                lambda: self.refresh_schema_item(item, schema_name)
            )

        elif item_type == "table":
            schema_name = item_data.get("schema")
            table_name = item_data.get("name")

            view_action = menu.addAction("Browse Data")
            view_action.triggered.connect(
                lambda: self.tableSelected.emit(schema_name, table_name)
            )

            refresh_action = menu.addAction("Refresh Table")
            refresh_action.triggered.connect(
                lambda: self.refresh_table_item(item, schema_name, table_name)
            )

            # Structure submenu
            structure_menu = menu.addMenu("Structure")

            # Add actions to structure menu
            columns_action = structure_menu.addAction("Show Columns")
            columns_action.triggered.connect(
                lambda: self.show_table_columns(schema_name, table_name)
            )

            indexes_action = structure_menu.addAction("Show Indexes")
            indexes_action.triggered.connect(
                lambda: self.show_table_indexes(schema_name, table_name)
            )

            # Sample query submenu
            query_menu = menu.addMenu("Sample Queries")

            # Add sample query actions
            select_action = query_menu.addAction("SELECT *")
            select_action.triggered.connect(
                lambda: self.generate_query(
                    f"SELECT * FROM {schema_name}.{table_name} LIMIT 100;"
                )
            )

            count_action = query_menu.addAction("COUNT(*)")
            count_action.triggered.connect(
                lambda: self.generate_query(
                    f"SELECT COUNT(*) FROM {schema_name}.{table_name};"
                )
            )

        elif item_type == "column":
            schema_name = item_data.get("schema")
            table_name = item_data.get("table")
            column_name = item_data.get("name")

            # Query submenu for column
            query_menu = menu.addMenu("Sample Queries")

            # Add sample query actions for column
            select_action = query_menu.addAction(f"SELECT {column_name}")
            select_action.triggered.connect(
                lambda: self.generate_query(
                    f"SELECT {column_name} FROM {schema_name}.{table_name} LIMIT 100;"
                )
            )

            distinct_action = query_menu.addAction(f"SELECT DISTINCT {column_name}")
            distinct_action.triggered.connect(
                lambda: self.generate_query(
                    f"SELECT DISTINCT {column_name} FROM {schema_name}.{table_name} LIMIT 100;"
                )
            )

            count_action = query_menu.addAction(f"COUNT DISTINCT {column_name}")
            count_action.triggered.connect(
                lambda: self.generate_query(
                    f"SELECT COUNT(DISTINCT {column_name}) FROM {schema_name}.{table_name};"
                )
            )

        # Only show menu if it has actions
        if not menu.isEmpty():
            menu.exec(self.viewport().mapToGlobal(position))

    def refresh_schema_item(self, item, schema_name):
        """Refresh a schema item."""
        # Remove all children
        item.takeChildren()

        # Add placeholder
        placeholder = QtWidgets.QTreeWidgetItem(item, ["Loading tables..."])
        item.addChild(placeholder)

        # Load tables
        self.load_tables(item, schema_name)

    def refresh_table_item(self, item, schema_name, table_name):
        """Refresh a table item."""
        # Remove all children
        item.takeChildren()

        # Add placeholder
        placeholder = QtWidgets.QTreeWidgetItem(item, ["Loading columns..."])
        item.addChild(placeholder)

        # Load columns
        self.load_columns(item, schema_name, table_name)

    def show_table_columns(self, schema_name, table_name):
        """Show table columns in a popup."""
        # This would be implemented to show detailed column info
        # For now, we'll just expand the table node
        for i in range(self.topLevelItemCount()):
            schema_item = self.topLevelItem(i)
            schema_data = schema_item.data(0, QtCore.Qt.UserRole)

            if (
                schema_data
                and schema_data.get("type") == "schema"
                and schema_data.get("name") == schema_name
            ):
                schema_item.setExpanded(True)

                for j in range(schema_item.childCount()):
                    table_item = schema_item.child(j)
                    table_data = table_item.data(0, QtCore.Qt.UserRole)

                    if (
                        table_data
                        and table_data.get("type") == "table"
                        and table_data.get("name") == table_name
                    ):
                        table_item.setExpanded(True)
                        break

                break

    def show_table_indexes(self, schema_name, table_name):
        """Show table indexes in a popup."""
        try:
            cursor = self.connection.cursor()
            cursor.execute(
                """
                SELECT
                    i.relname AS index_name,
                    a.attname AS column_name,
                    am.amname AS index_type
                FROM
                    pg_class t,
                    pg_class i,
                    pg_index ix,
                    pg_attribute a,
                    pg_am am,
                    pg_namespace n
                WHERE
                    t.oid = ix.indrelid
                    AND i.oid = ix.indexrelid
                    AND a.attrelid = t.oid
                    AND a.attnum = ANY(ix.indkey)
                    AND t.relkind = 'r'
                    AND i.relam = am.oid
                    AND t.relnamespace = n.oid
                    AND n.nspname = %s
                    AND t.relname = %s
                ORDER BY
                    i.relname, array_position(ix.indkey, a.attnum)
            """,
                (schema_name, table_name),
            )

            indexes = cursor.fetchall()
            cursor.close()

            if not indexes:
                QtWidgets.QMessageBox.information(
                    self,
                    "Indexes",
                    f"No indexes found for table '{schema_name}.{table_name}'",
                )
                return

            # Create a simple dialog to display indexes
            dialog = QtWidgets.QDialog(self)
            dialog.setWindowTitle(f"Indexes for {schema_name}.{table_name}")
            dialog.resize(400, 300)

            layout = QtWidgets.QVBoxLayout(dialog)

            # Create a table widget to display indexes
            table = QtWidgets.QTableWidget()
            table.setColumnCount(3)
            table.setHorizontalHeaderLabels(["Index Name", "Column", "Type"])
            table.setRowCount(len(indexes))

            for i, index in enumerate(indexes):
                table.setItem(i, 0, QtWidgets.QTableWidgetItem(index[0]))
                table.setItem(i, 1, QtWidgets.QTableWidgetItem(index[1]))
                table.setItem(i, 2, QtWidgets.QTableWidgetItem(index[2]))

            table.resizeColumnsToContents()
            layout.addWidget(table)

            # Add a close button
            button = QtWidgets.QPushButton("Close")
            button.clicked.connect(dialog.accept)
            layout.addWidget(button)

            dialog.setLayout(layout)
            dialog.exec()

        except Exception as e:
            QtWidgets.QMessageBox.warning(
                self,
                "Error Loading Indexes",
                f"Failed to load indexes for table '{schema_name}.{table_name}':\n{str(e)}",
            )

    def generate_query(self, query):
        """Generate a SQL query and emit a signal with it."""
        # Emit the signal with the generated query
        self.queryGenerated.emit(query)



========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/database/__init__.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/database/connection.py ==========
import psycopg2
from psycopg2 import OperationalError


# Define a custom exception for better error handling context
class ConnectionError(Exception):
    """Custom exception for database connection errors."""

    pass


def connect_to_db(host, port, dbname, user, password):
    """
    Establishes a connection to the PostgreSQL database.

    Args:
        host (str): Database host address.
        port (str): Database port number.
        dbname (str): Database name.
        user (str): Username for authentication.
        password (str): Password for authentication.

    Returns:
        psycopg2.connection: The connection object if successful.

    Raises:
        ConnectionError: If the connection fails for any reason.
    """
    conn = None
    try:
        print(
            f"Attempting to connect: dbname='{dbname}' user='{user}' host='{host}' port='{port}'"
        )  # Debug print
        conn = psycopg2.connect(
            host=host,
            port=port,
            dbname=dbname,
            user=user,
            password=password,
            connect_timeout=5,  # Add a timeout (in seconds)
        )
        print("Connection successful!")  # Debug print
        return conn
    except OperationalError as e:
        # Catch specific psycopg2 connection errors
        print(f"Connection failed: {e}")  # Debug print
        # Raise a more specific custom error
        raise ConnectionError(f"Could not connect to database.\nDetails: {e}") from e
    except Exception as e:
        # Catch any other unexpected errors during connection attempt
        print(f"An unexpected error occurred during connection: {e}")  # Debug print
        if conn:
            conn.close()  # Ensure connection is closed if partially opened
        raise ConnectionError(f"An unexpected error occurred.\nDetails: {e}") from e


# Example of how to use (for testing purposes, not typically run directly)
if __name__ == "__main__":
    # --- IMPORTANT ---
    # Replace with actual test database details
    # DO NOT COMMIT ACTUAL CREDENTIALS
    test_details = {
        "host": "localhost",
        "port": "5432",
        "dbname": "your_test_db",
        "user": "your_test_user",
        "password": "your_test_password",
    }

    try:
        connection = connect_to_db(**test_details)
        if connection:
            print("\n--- Test Connection Successful ---")
            print(
                f"Connected to PostgreSQL server version: {connection.server_version}"
            )
            # You can perform a simple query here if needed
            # cur = connection.cursor()
            # cur.execute("SELECT version();")
            # print(cur.fetchone())
            # cur.close()
            connection.close()
            print("--- Test Connection Closed ---")
    except ConnectionError as err:
        print(f"\n--- Test Connection Failed ---")
        print(err)
    except ImportError:
        print(
            "Error: psycopg2 library not found. Please install it: pip install psycopg2-binary"
        )


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/database/odoo_helper.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/config.py ==========
# In src/data_explorer/config.py

import json
import os
from pathlib import Path

class Config:
    """Configuration manager for the application."""
    
    def __init__(self):
        # Determine config file location
        self.config_dir = Path.home() / ".pgdataexplorer"
        self.config_file = self.config_dir / "config.json"
        
        # Default configuration
        self.defaults = {
            "recent_connections": [],
            "window": {
                "size": [1000, 700],
                "position": [100, 100],
                "maximized": False
            },
            "splitters": {
                "h_splitter": [250, 750],
                "v_splitter": [300, 400]
            },
            "query_history": [],
            "query_limit": 100  # Default LIMIT value for SELECT queries
        }
        
        # Load configuration
        self.config = self.load()
    
    def load(self):
        """Load configuration from file."""
        # Create config directory if it doesn't exist
        if not self.config_dir.exists():
            self.config_dir.mkdir(parents=True)
        
        # Create default config if file doesn't exist
        if not self.config_file.exists():
            return self.defaults.copy()
        
        # Load config from file
        try:
            with open(self.config_file, 'r') as f:
                config = json.load(f)
            
            # Ensure all default keys exist
            for key, value in self.defaults.items():
                if key not in config:
                    config[key] = value
            
            return config
        except Exception as e:
            print(f"Error loading config: {e}")
            return self.defaults.copy()
    
    def save(self):
        """Save configuration to file."""
        try:
            with open(self.config_file, 'w') as f:
                json.dump(self.config, f, indent=2)
        except Exception as e:
            print(f"Error saving config: {e}")
    
    def get(self, key, default=None):
        """Get a configuration value."""
        return self.config.get(key, default)
    
    def set(self, key, value):
        """Set a configuration value."""
        self.config[key] = value
        self.save()
    
    def add_recent_connection(self, connection_details):
        """Add a connection to the recent connections list."""
        # Remove password for security
        connection_copy = connection_details.copy()
        if "password" in connection_copy:
            connection_copy["password"] = ""  # Clear password
        
        # Add to recent connections
        recent = self.config.get("recent_connections", [])
        
        # Remove if already exists
        recent = [c for c in recent if not (
            c.get("host") == connection_copy.get("host") and
            c.get("port") == connection_copy.get("port") and
            c.get("dbname") == connection_copy.get("dbname") and
            c.get("user") == connection_copy.get("user")
        )]
        
        # Add to beginning of list
        recent.insert(0, connection_copy)
        
        # Limit to 10 recent connections
        recent = recent[:10]
        
        # Update config
        self.config["recent_connections"] = recent
        self.save()
    
    def add_query_history(self, query):
        """Add a query to the history."""
        # Get existing history
        history = self.config.get("query_history", [])
        
        # Remove if already exists
        if query in history:
            history.remove(query)
        
        # Add to beginning of list
        history.insert(0, query)
        
        # Limit to 50 queries
        history = history[:50]
        
        # Update config
        self.config["query_history"] = history
        self.save()
    
    def get_query_history(self):
        """Get the query history."""
        return self.config.get("query_history", [])
    
    def get_recent_connections(self):
        """Get the recent connections."""
        return self.config.get("recent_connections", [])

========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/__init__.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/utils/__init__.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/utils/helpers.py ==========


========== FILE: /Users/ccmaloney/Documents/Projects/pg_data_explorer/src/data_explorer/main.py ==========
import sys
from PySide6 import QtWidgets
from data_explorer.ui.main_window import MainWindow


def run():
    """
    Initializes and runs the Qt application.
    """
    # Create the Qt Application
    app = QtWidgets.QApplication(sys.argv)

    # Create and show the main window
    window = MainWindow()
    window.show()

    # Run the application's event loop
    sys.exit(app.exec())


if __name__ == "__main__":
    # This ensures the run function is called only when the script is executed directly
    run()


